Изучаем: return, инкапсуляцию, наследование, переоределение, интефрейсы, циклы, Math, операторы ветвления, паттерны*. 

Суть задания: 
	Написать различные варианты калькуляторов (несколько отдельных классов) которые делают одно и тоже различными способами
	 (какой-то использует только собственные методы, какой-то обращается к библиотеке Math). Тем самым вы в полной мере испробуете
	  инкапсуляцию, наследование.
	Изучить плюсы и минусы использование абстракции, интерфейсов.
	Изучить библиотеку (класс) Math из jdk. (https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html)
	Изучить работу с полями класса
	Изучить паттерны Декоратор, Компоновщик, Адаптер

Задания разделить по пакетам. Все классы с названием ****Main должны быть помещены в пакет runners.
Должно получиться так:

-home_work_3
	-calcs
		-simple
		....
	-runners
		....

Такое разделение классов позволяет лучше структурировать пакет и в будущем будет удобно их поддерживать.

Калькуляторы:

Для начала просто посчитаем выражения. Просто пишем как есть данные выражения, как в ДЗ с операторами. В комментарии
напротив выражений нужно записать их результат, таким образом в будущем мы сможем сверить результат выполнения последующих задач.

/**1. Создать класс WithoutCalculatorMain в котором необходимо посчитать следующие выражения:
	1.1 4.1 + 15 * 7 + (28 / 5) ^ 2. Вывести сохранённый результат в консоль. Внимание, знак "^" обозначает возведение в степень.

Достаточно простые выражения, с которыми, на данный момент, проблем уже не должно возникать. Давайте больше структурировать
 наш код. В будущем это позволит довольно быстро и безболезненно увеличивать функциональность приложения.

Последующие классы должны быть созданы в пакете calcs.simple*/

/**2. Создать класс CalculatorWithOperator.
	2.1 Все методы объявленные в данном классе НЕ статические (не имеют модификатор static). 
	2.2 В классе должны присутствовать математические методы:
		2.2.1 4 базовых математических метода (деление, умножение, вычитание, сложение) каждый из этих методов должен
		 принимать два параметра (определитесь с их типами) и должны возвращать результат (определиться с возвращаемым
		 типом результата) при помощи ключевого слово return.
		2.2.2 3 метода (Возведение в целую степень дробного положительного числа, Модуль числа, Корень из числа). 
	2.3 В методах можно использовать любые арифметические операторы.
	2.4 Использование библиотеки Math ЗАПРЕЩЕНО! (кроме извлечения корня). Если у Вас плохо с математикой, то для реализации
	метода "Корень из числа" можно воспользоваться библиотекой Math.
	2.5 Создать класс CalculatorWithOperatorMain в котором будет точка входа (main метод). В main методе требуется создать
	экземпляр калькулятора и используя методы из данного экземпляра посчитать выражения из задания 1. Вывести в консоль результат.*/
/**3. Создать класс CalculatorWithMathCopy.
	3.1 Все методы объявленные в данном классе НЕ статические (не имеют модификатор static). 
	3.2 В классе должны присутствовать математические методы:
		3.2.1 4 базовых математических метода (деление, умножение, вычитание, сложение). Скопировать базовые математические операции из CalculatorWithOperator.
		3.2.2 3 метода (Возведение в целую степень дробного положительного числа, Модуль числа, Корень из числа).
		Данные методы должны содержать в своём теле вызов библиотеки Math и возврат полученного результата.
	3.3 Создать класс CalculatorWithMathCopyMain в котором будет точка входа (main метод). В main методе требуется создать
	экземпляр калькулятора и используя методы из данного экземпляра посчитать выражения из задания 1. Вывести в консоль результат.*/
/**4. Создать класс CalculatorWithMathExtends.
	4.1 Все методы объявленные в данном классе НЕ статические (не имеют модификатор static).
	4.2 Данный класс должен наследовать класс CalculatorWithOperator.
	4.3 В классе должны присутствовать
		4.3.1 4 базовых математических метода (деление, умножение, вычитание, сложение) НЕ ДОЛЖНЫ быть объявлены в классе,
		а должны быть унаследованы от родительского класса.
		4.3.2 3 метода (Возведение в целую степень дробного положительного числа, Модуль числа, Корень из числа).
		Данные методы должны ПЕРЕОПРЕДЕЛЯТЬ методы родительского класса и должны содержать в своём теле вызов библиотеки
		 Math и возврат полученного результата .
	4.4 Создать класс CalculatorWithMathExtendsMain в котором будет точка входа (main метод). В main методе требуется создать
	экземпляр калькулятора и используя методы из данного экземпляра посчитать выражения из задания 1. Вывести в консоль результат.*/

Пройдя пункты перечисленные выше вы попробовали различными способами создать класс калькулятора, все перечисленные классы
 умеют одно и тоже но реализуют различными способами. Кто-то наследует, кто-то переопределяет, кто-то в тупую копирует.
 Если выбирать из трёх вариантов то очевидный выбор наследование и переопределение. Но из-за ограничений по наследованию
 его используют очень редко. Далее посмотрим как мы можешь расширить функционал и вроде как попробуем дальше пользоваться наследованием.

Предлагаю обсудить идею классов с названиями CalculatorWithCounter*****. Начнём с жизненной аналогии. 
Современные принтеры имеют такую функцию как запоминание количества распечатанных страниц с текущим картриджем и за всю
жизнь принтера. На принтере вы печатаете 10 страниц и эта информация записывается в память принтера. А потом сервисный центр
использует эту информацию для анализа как много вы печатали на данном принтере и возможно сделают вывод о том что вы использовали
бытовой принтер в коммерческих целях и откажут вам в гарантийном ремонте. Ладно, опустим подробности для чего это можно использовать.
Они просто идут и спрашивают, принтер, сколько тебя использовали)) и он выдаёт эту информацию.

Теперь к сути.
Данные классы будут выполнять функцию учёта количества использований калькуляторов. Соответственно когда у калькулятора
вызывают метод сложения, внутри калькулятора должен быть увеличен счётчик количества использований, с другими математическими
методами тоже самое.

Перейдём к классике. Просто создаём класс и решаем поставленную задачу.

Последующие классы должны быть созданы в пакете calcs.additional

/**5. Создать класс CalculatorWithCounterClassic.
	5.1 Все методы объявленные в данном классе НЕ статические (не имеют модификатор static). 
	5.2 Данный класс должен наследовать класс CalculatorWithMathExtends.
	5.3 В классе должен быть метод void incrementCountOperation() который должен увеличивать внутренний счётчик в калькуляторе.
	5.4 В классе должен быть метод long getCountOperation() который должен возвращать количество использований данного калькулятора. 
	5.5 Создать класс CalculatorWithCounterClassicMain в котором будет точка входа (main метод). В main методе требуется
	создать экземпляр калькулятора и используя методы из данного экземпляра посчитать выражения из задания 1, при каждой
	математической операции самостоятельно вызывать метод incrementCountOperation() для увеличения счётчика. Вывести в консоль результат.*/

Какая проблема данного класса? Вроде всё красиво, всё ещё есть наследование, всё удобно разложено по отдельным методам. 
Но как всегда есть две беды... Дураки (программисты) и дороги (наш класс CalculatorWithCounterClassic). Дураки не умеют
пользоваться дорогами, программисты не умеют пользоваться нашим классом CalculatorWithCounterClassic. Что обычно делают
на дорогах чтобы дураки на них не убивались? -Правильно, делают дороги интуитивно понятными, безопасными, уменьшают количество
мусорных знаков и делают так чтобы при их использовании дураку нельзя было бы ошибиться.

Так вот проблема нашего CalculatorWithCounterClassic в том, что для увеличения счётчика программиста нужно заставить воспользоваться
методом incrementCountOperation() чтобы в итоге наш счётчик операций был увеличен на 1. Можно сколько угодно настаивать на том,
 чтобы коллеги читали документацию к вашим классам, сколько угодно можно рассказывать, что там есть много важного... Они всё равно не
 будут её читать...
  Пока в продакшене проблем не возникнет, - документацию они не отроют в 90% случаев.

Поэтому давайте немного воспользуемся прелестями наследования и большей степенью инкапсуляции. Просто сами, внутри нашего нового калькулятора,
 будем вызывать этот метод incrementCountOperation и снимем эту обязанность с программиста.

/**6. Создать класс CalculatorWithCounterAutoSuper.
	6.1 Все методы и поля объявленные в данном классе НЕ статические (не имеют модификатор static).
	6.2 Данный класс наследует класс CalculatorWithMathExtends.
	6.3 Данный класс переопределяет все методы полученные в результате наследования и в этих методах должен быть реализован механизм
	учёта их использования (учёт общий для всех методов класса), а вместо реализации математики при помощи ключевого слова super
	вызывает данный метод у родителя. Например вызвали метод plus(7, 3) который должен сложить два числа и вернуть результат сложения.
	Внутри метода plus() пишем реализацию учета, а после делаем вызов super.plus(7, 3). Использование super позволит вызвать реализацию из родительского класса.
	6.4 В классе должен быть метод long getCountOperation() который должен возвращать количество использований данного калькулятора.
	При вызове данного метода счётчик учёта не увеличивается.
	6.5 Создать класс CalculatorWithCounterAutoSuperMain в котором будет точка входа (main метод). В main методе требуется создать
	экземпляр калькулятора и используя методы из данного экземпляра посчитать выражения из задания 1. Вывести в консоль результаты
	посчитанных выражений и результат метода getCountOperation().*/

Отлично, мы воспользовались наследованием и вроде получился красивый код. А теперь давайте подумаем, а если нам скажут что нам нужно
 создать такого наследника не только для CalculatorWithMathExtends но и для CalculatorWithOperator и CalculatorWithMathCopy..... и этот список
  нескончаем так как калькуляторы могут быть добавлены в проект в любом количестве и любым программистом. При добавлении нового калькулятора,
   который должен будет иметь функции по учёту количества использований, нам каждый раз нужно будет совершать подвиг (писать тот же код что и CalculatorWithCounterSuper)
   и это не то чтобы плохо, но отнимает большое количество времени, растёт количество классов которые нужно контролировать и тестировать. Это превращается в лавину!

Давайте рассмотрим решение при помощи композиции. Композиция позволяет создать один класс. Но в нём нужно будет постоянно добавлять
 конструкторы для новых калькуляторов, менять код методов. Код станет сложнее (эту проблему мы решим дальше) но от лавины по количеству
 классов точно уйдём. Но это вы ощутите выполнив уже следующее задание.
Больше о композиции можно почитать тут https://refactoring.guru/ru/design-patterns/composite

7. Создать класс CalculatorWithCounterAutoComposite.
	7.1 Внутри класса нельзя создавать объекты, можно пользоваться только тем что передал вам пользователь вашего класса.
	7.2 Все методы объявленные в данном классе НЕ статические (не имеют модификатор static).
	7.3 В данном классе должны быть следующие варианты конструктора:
		7.3.1 Принимающий объект типа CalculatorWithOperator
		7.3.2 Принимающий объект типа CalculatorWithMathCopy
		7.3.3 Принимающий объект типа CalculatorWithMathExtends
	7.4 Данный класс напрямую не умеет считать математику, он умеет делегировать расчёт математики другим калькуляторам переданным в конструктор
	7.5 В классе должны присутствовать математические методы:
		7.5.1 4 базовых математических метода (деление, умножение, вычитание, сложение).
		7.5.2 3 метода (Возведение в целую степень дробного положительного числа, Модуль числа, Корень из числа).
	7.6 В классе должен быть метод long getCountOperation() который должен возвращать количество использований данного калькулятора.
	 При вызове данного метода счётчик учёта не увеличивается.
	7.7 Создать класс CalculatorWithCounterAutoCompositeMain в котором будет точка входа (main метод). В main методе требуется создать
	экземпляр калькулятора и используя методы из данного экземпляра посчитать выражения из задания 1. Вывести в консоль результаты
	посчитанных выражений и результат метода getCountOperation().

Пройдя всё вышеперечисленное мы должны понять, что идём к тупику. Данный пункт нарочно усложнён тремя конструкторами. Он нужен для того,
чтобы показать, что писать наш класс именно так - безумная идея. Из-за возможного нарастания количества всевозможных калькуляторов,
для которых мы должны в класс CalculatorWithCounterAutoComposite добавить конструкторы, поля и тучу кода... Вроде уходили от наследования
 и говорили о том, что оно не желательно... а это получается желательно??? -на самом деле нет, мы тут ещё не закончили.

Для того чтобы перейти дальше, необходимо добавить один важный компонент и с ним всё заиграет новыми красками, и он позволит писать более удобный код.

8. Создать интерфейс ICalculator. Данный интерфейс создайте в пакете calcs.api . Можете прогуглить слово API, оно очень универсально.
 Такие пакеты обычно содержат интерфейсы, перечисления и в некоторых случаях абстрактные классы.
	8.1 В данном интерфейсе должны быть объявлены методы:
		8.1.1 4 базовых математических метода (деление, умножение, вычитание, сложение).
		8.1.2 3 метода (Возведение в целую степень дробного положительного числа, Модуль числа, Корень из числа).
	8.2 На данный момент данный интерфейс вы должны прописать во всех классах калькуляторов созданных нами в пакетах calcs.simple

Данный интерфейс позволит использовать композицию так чтобы это всё-таки было удобно.

9. Создать класс CalculatorWithCounterAutoCompositeInterface. 
	9.1 Внутри класса нельзя создавать объекты, можно пользоваться только тем что передал вам пользователь вашего класса.
	9.2 Все методы объявленные в данном классе НЕ статические (не имеют модификатор static).
	9.3 В данном классе должен быть только конструктор принимающий объект типа ICalculator
	9.4 Данный класс напрямую не умеет считать математику, он умеет делегировать расчёт математики другим калькуляторам переданным в конструктор
	9.5 В классе должны присутствовать все методы объявленные в интерфейсе.
	9.6 В классе должен быть метод long getCountOperation() который должен возвращать количество использований данного калькулятора.
	При вызове данного метода счётчик учёта не увеличивается.
	9.7 Создать класс CalculatorWithCounterAutoCompositeInterfaceMain в котором будет точка входа (main метод). В main методе требуется
	 создать экземпляр калькулятора и используя методы из данного экземпляра посчитать выражения из задания 1. Вывести в консоль результаты
	  посчитанных выражений и результат метода getCountOperation().

Вот мы пришли к тому что сочетание композиции и интерфейса нам позволило остановить ту лавину кода, конструкторов и классов...
В общем все проблемы которые нас преследовали ранее в предыдущих пунктах нашего задания. Наш код стал простым и соответственно понятным,
его легче поддерживать так как теперь наш вариант CalculatorWithCounterAutoCompositeInterface будет работать с любым калькулятором
который реализует интерфейс ICalculator. Если вдруг вы захотите выпустить свой калькулятор в виде библиотеки - то в этой библиотеке
будет всего лишь два файла CalculatorWithCounterAutoCompositeInterface и ICalculator. Все кто захочет воспользоваться вашими наработками,
 просто создадут свой калькулятор реализуя интерфейс ICalculator. А логику учёта будут использовать ту что вы написали в
 классе CalculatorWithCounterAutoCompositeInterface.

10*. Создать CalculatorWithMemory.
	10.1 Данный калькулятор предназначен для того чтобы расширить возможности калькулятора и обеспечить его дополнительной функцией памяти.
	В принципе работает как калькулятор из реальной жизни.
	10.2 Все методы объявленные в данном классе НЕ статические (не имеют модификатор static).
	10.3 Данный класс напрямую не умеет считать математику.
	10.4 В классе должны присутствовать математические методы:
		10.4.1 4 базовых математических метода (деление, умножение, вычитание, сложение).
		10.4.2 3 метода (Возведение в целую степень дробного положительного числа, Модуль числа, Корень из числа).
	10.5 Функция памяти работает через методы:
		10.5.1 Записать в память результат выполнения последнего вызванного метода. У данного метода не должно быть параметров.
		Данный метод вызывается непосредтвенно пользователем, а не автоматический.
		10.5.2 Получить из памяти записанное значение. При получении записи из памяти память стирается, при записи нового значения
		память перезаписывается. Данный метод вызывается непосредтвенно пользователем, а не автоматический.
	10.6 Создать класс CalculatorWithMemoryMain в котором будет точка входа (main метод). В main методе требуется создать экземпляр
	калькулятора и используя методы из данного экземпляра посчитать выражения из задания 1. Вывести в консоль результат. В мэйне запрещается
	 использование переменных для хранения значений участвующих в просчёте, а также результатов работы методов калькулятора.

11*. Создать класс CalculatorWithCounterAutoDecorator и CalculatorWithMemoryDecorator //INSTANCE OF
	11.1 Отличие от предыдущих CalculatorWithCounterAutoCompositeInterface и CalculatorWithMemory в том что данные классы реализуют интерфейс ICalculator.
	11.2 Данный подход позволяет назвать данный классы "Декораторами". Декоратор - это популярный паттерн который позволяет комбинировать
	 и дополнять новыми возможностями объекты (в нашем случае калькуляторы) не меняя код в их классе. Тем самым мы приходим к тому что мы не наследуем
	 классы для их расширения и не привязываемся к реализации конкретного калькулятора.
	11.3 О декораторах можно прочитать по ссылкам:
		11.3.1 https://refactoring.guru/ru/design-patterns/decorator
		11.3.2 https://www.wikiwand.com/ru/%D0%94%D0%B5%D0%BA%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
	11.4 Добавить в эти классы метод ICalculator getCalculator() который будут возвращать вложенный в них калькулятор.
	11.5 Создать класс CalculatorDecoratorMain в котором будет точка входа (main метод). Cоздать переменную типа ICalculator записав в
	неё новый экземпляр класса CalculatorWithCounterDecorator которому в конструктор был передан новый экземпляр класса CalculatorWithMemoryDecorator
	 которому в конструтор был передан новый экземпляр класса CalculatorWithMathExtends. Используя созданную переменную посчитать выражения из задания 1.
	11.6 Вывести в консоль результат. Вывести количество использований калькулятора. Вывести последнее сохранённое значение в памяти.

12**. Написать класс CalculatorStringExpression. Данное задание направлено на изучение паттера Адаптер.
	12.0 О адаптерах можно прочитать по ссылкам:
		12.0.1 https://refactoring.guru/ru/design-patterns/adapter
		12.0.2 https://www.wikiwand.com/ru/%D0%90%D0%B4%D0%B0%D0%BF%D1%82%D0%B5%D1%80_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
	12.1 реализующий разбор (парсинг) СТРОКИ с математическим выражением:
	12.2 Класс должен понимать операторы: + - \ * ^ || 
	12.3 Класс должен понимать ( )
	12.4 Класс должен строго учитывать приоритеты в данном выражении
	12.5 Класс должен уметь парсить в строке константные значение: PI, E (Экспонента)
	12.6 Класс должен контролировать что в строке могут быть только допустие символы (числа, операторы, скобки, константы)
	12.7 Класс должен контролировать чтобы выражение было валидным (2 + 2 - хорошо, 2 + - плохо)
	
Далее задания выполнять только после прохождения темы "Тестирование"

13. Написать тест который будет тестировать все реализации ICalculator. Пример данных взять из задания 1